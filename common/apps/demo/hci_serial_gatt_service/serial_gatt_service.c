/*
 * This file has been automatically generated by the WICED Embedded Designer.
 * Bluetooth Application.
 *
 */

/** serial_gatt_service.c
 *
 */

#include "wiced.h"
#include "wiced_bt_dev.h"
#include "wiced_bt_ble.h"
#include "wiced_bt_uuid.h"
#include "wiced_bt_gatt.h"
#include "wiced_hal_nvram.h"
#include "wiced_hal_gpio.h"
#include "wiced_bt_app_hal_common.h"
#include "wiced_platform.h"
#include "wiced_bt_trace.h"
#include "serial_gatt_service.h"
#include "wiced_transport.h"
#include "hci_control_api.h"
#include "gatt_server_db.h"
#include "wiced_bt_cfg.h"
#include "wiced_timer.h"
#include "wiced_bt_l2c.h"

/*******************************************************************
 * Constants
 ******************************************************************/

/* HCI Transport Header (Command  Code, Group Code, Length) */
#define HCI_HEADER_SIZE                                 4

#define SERIAL_GATT_SERVICE_MTU_NEGOTIATION_TIMEOUT     2       // in seconds
#define SERIAL_GATT_SERVICE_ACK_TIMEOUT                 500     // in milliseconds
#define SERIAL_GATT_SERVICE_IDLE_TIMEOUT                3       // in seconds

#define SERIAL_GATT_SERVICE_RX_MTU                      512

#define SERIAL_GATT_SERVICE_TRANSPORT_BUFF_NB           2
#define SERIAL_GATT_SERVICE_TRANSPORT_BUFF_SIZE         (SERIAL_GATT_SERVICE_RX_MTU + \
                                                         HCI_HEADER_SIZE)

typedef enum
{
    SERIAL_GATT_SERVICE_CONN_IDLE = 0,
    SERIAL_GATT_SERVICE_CONN_ACTIVE,

} serial_gatt_service_conn_t;

/* BLE connection parameters when in Serial Service is 'Active' (data sent/received) */
#define SERIAL_GATT_SERVICE_ACTIVE_INT_MIN              6
#define SERIAL_GATT_SERVICE_ACTIVE_INT_MAX              6
#define SERIAL_GATT_SERVICE_ACTIVE_LATENCY              0
#define SERIAL_GATT_SERVICE_ACTIVE_CONN_TIMEOUT         200

/* BLE connection parameters when in Serial Service is 'Idle' (no data sent/received) */
#define SERIAL_GATT_SERVICE_IDLE_INT_MIN                60
#define SERIAL_GATT_SERVICE_IDLE_INT_MAX                100
#define SERIAL_GATT_SERVICE_IDLE_LATENCY                0
#define SERIAL_GATT_SERVICE_IDLE_CONN_TIMEOUT           2000

#if 0
#define BSG_DEBUG_TRACE                                 WICED_BT_TRACE
#else
#define BSG_DEBUG_TRACE(...)
#endif

/*******************************************************************
 * Structures
 ******************************************************************/
typedef struct
{
    uint8_t in;                                             // In index (location to insert)
    uint8_t out;                                            // Out Index (location to extract)
    uint8_t credit[SERIAL_GATT_SERVICE_TRANSPORT_BUFF_NB];
} serial_gatt_credit_queue_t;

typedef struct
{
    uint8_t                         *p_transport_buffer;    // Rx Buffer allocated
    uint8_t                         nb_transport_allocated; // Number of transport allocated
    uint8_t                         credits;                // Nb 'Credit' in this buffer
    uint16_t                        length;                 // data length
    serial_gatt_credit_queue_t      credit_queue;           // Credit queue (to be acked)
} serial_gatt_rx_buffer_cb_t;

// Application state control block
typedef struct
{
    wiced_bool_t                    notifications_enabled;  // True if client enabled notifications
    uint8_t                         tx_credits;             // number of credits we have to send OTA data
    uint8_t                         rx_credits_max;         // maximum number of credits to give to peer
    uint8_t                         rx_credits;             // current number of credits to give to peer
    uint16_t                        peer_mtu;               // negotiated MTU
    wiced_bool_t                    mtu_update;             // Indicate if MTU must be sent to peer (inband)
    uint16_t                        conn_id;                // connection ID to send data
    uint16_t                        tx_len;                 // Length of the data in the TX buffer
    uint16_t                        tx_offset;              // Offset of the data in the TX buffer
    uint8_t*                        p_tx_buffer;            // Pointer to the TX buffer
    wiced_transport_buffer_pool_t*  p_transport_pool;       // Transport pool used to send data to the MCU
    uint8_t                         peer_bdaddr[BD_ADDR_LEN];   // BdAddr of the peer device
    serial_gatt_rx_buffer_cb_t      rx_buffer_cb;           // Rx buffer control block
    serial_gatt_service_conn_t      conn_state;             // Active or Idle
} serial_gatt_state_t;

/*******************************************************************
 * Variable Definitions
 ******************************************************************/
serial_gatt_state_t serial_gatt_state;

wiced_bool_t        serial_gatt_timer_initialized = WICED_FALSE;
wiced_timer_t       serial_gatt_mtu_timer;
wiced_timer_t       serial_gatt_ack_timer;
wiced_timer_t       serial_gatt_idle_timer;

/*******************************************************************
 * Function Prototypes
 ******************************************************************/
static void         serial_gatt_service_mtu_timer_stop(void);
static void         serial_gatt_service_ack_timer_stop(void);
static void         serial_gatt_service_idle_timer_stop(void);

static void         serial_gatt_service_mtu_timer_callback      (uint32_t arg);
static void         serial_gatt_service_ack_timer_callback      (uint32_t arg);
static void         serial_gatt_service_idle_timer_callback     (uint32_t arg);

static wiced_bool_t serial_gatt_service_process_forward_data    (uint8_t *p_buffer,
                                                                 uint16_t offset, uint16_t length);
static void         serial_gatt_service_send_data               (wiced_bool_t return_credits);
static void         serial_gatt_service_tx_complete             (uint8_t result);
static void         serial_gatt_service_send_tx_complete_evt    (uint16_t conn_id, uint8_t result);
static void         serial_gatt_service_send_connected_evt      (uint8_t *bd_addr,
                                                                 uint16_t conn_id);
static void         serial_gatt_service_send_disconnected_evt   (uint16_t conn_id);

static void         serial_gatt_service_transport_credit_insert (uint8_t credit);
static uint8_t      serial_gatt_service_transport_credit_extract(void);

static uint16_t     serial_gatt_service_header_write(uint8_t *p_buffer, uint8_t flags,
                                                     uint8_t credits, uint16_t mtu);
static int          serial_gatt_service_header_parse(uint8_t *p_credits, uint16_t *p_mtu,
                                                     uint8_t **pp_data, uint8_t *p_buffer,
                                                     uint16_t buffer_len);

static void         serial_gatt_service_change_conn_param(serial_gatt_service_conn_t conn_state);

static void         serial_gatt_service_bsg_mtu_handler(uint16_t mtu);

/*******************************************************************
 * Function Definitions
 ******************************************************************/
/*
 * This function is executed in the BTM_ENABLED_EVT management callback.
 */
void serial_gatt_service_app_init(void)
{
    memset(&serial_gatt_state, 0, sizeof(serial_gatt_state));

    if (!serial_gatt_timer_initialized)
    {
        serial_gatt_timer_initialized = WICED_TRUE;

        if (wiced_init_timer(&serial_gatt_mtu_timer, serial_gatt_service_mtu_timer_callback, 0,
                WICED_SECONDS_TIMER) != WICED_SUCCESS )
        {
            WICED_BT_TRACE("failed init mtu timer");
        }
        if (wiced_init_timer(&serial_gatt_ack_timer, serial_gatt_service_ack_timer_callback, 0,
                WICED_MILLI_SECONDS_TIMER) != WICED_SUCCESS )
        {
            WICED_BT_TRACE("failed init rx timer");
        }
        if (wiced_init_timer(&serial_gatt_idle_timer, serial_gatt_service_idle_timer_callback, 0,
                WICED_SECONDS_TIMER) != WICED_SUCCESS )
        {
            WICED_BT_TRACE("failed init idle timer");
        }
    }

    /* Allocate buffer pool to send data to MCU (add 4 bytes for the transport header) */
    serial_gatt_state.p_transport_pool = wiced_transport_create_buffer_pool(
            SERIAL_GATT_SERVICE_TRANSPORT_BUFF_SIZE, SERIAL_GATT_SERVICE_TRANSPORT_BUFF_NB);
    if (serial_gatt_state.p_transport_pool == NULL)
    {
        WICED_BT_TRACE("ERR: BSG create transport pool failed");
    }
}

/*
 * serial_gatt_service_mtu_timer_stop
 */
static void serial_gatt_service_mtu_timer_stop(void)
{
    if (wiced_is_timer_in_use(&serial_gatt_mtu_timer))
        wiced_stop_timer(&serial_gatt_mtu_timer);
}

/*
 * serial_gatt_service_ack_timer_stop
 */
static void serial_gatt_service_ack_timer_stop(void)
{
    if (wiced_is_timer_in_use(&serial_gatt_ack_timer))
        wiced_stop_timer(&serial_gatt_ack_timer);
}

/*
 * serial_gatt_service_idle_timer_stop
 */
static void serial_gatt_service_idle_timer_stop(void)
{
    if (wiced_is_timer_in_use(&serial_gatt_idle_timer))
        wiced_stop_timer(&serial_gatt_idle_timer);
}


/*
 * Timer callback routine
 */
static void serial_gatt_service_mtu_timer_callback(uint32_t arg)
{
    // master did not send MTU request, default is 23 bytes.
    serial_gatt_service_mtu_handler(serial_gatt_state.conn_id, GATT_DEF_BLE_MTU_SIZE);
}

/*
 * Ack timeout
 */
static void serial_gatt_service_ack_timer_callback(uint32_t arg)
{
    BSG_DEBUG_TRACE("serial_gatt_service_ack_timer_callback\n");
    // it's time to send RxCredit (if there are some)
    serial_gatt_service_send_data(WICED_TRUE);
}

/*
 * serial_gatt_service_idle_timer_callback
 * This timer means that no Serial data has been sent/received for some time.
 * We can reduce the connection Interval to save power
 */
static void serial_gatt_service_idle_timer_callback(uint32_t arg)
{
    WICED_BT_TRACE("serial_gatt_service_idle_timer_callback\n");

    serial_gatt_service_change_conn_param(SERIAL_GATT_SERVICE_CONN_IDLE);
}

/*
 * Handles Write Requests received from Client device
 */
wiced_bt_gatt_status_t serial_gatt_service_write_handler(uint16_t conn_id, wiced_bt_gatt_write_t *p_write_req)
{
    wiced_bt_gatt_status_t  status = WICED_BT_GATT_INVALID_HANDLE;
    uint16_t                len = p_write_req->val_len;
    uint8_t                 flags;
    uint8_t                 credit;
    uint8_t*                p_data;
    uint8_t*                p_trans_buffer;
    int                     header_size;
    uint16_t                mtu;
    wiced_bool_t            notifications_enabled;

    // process characteristic client configuration descriptor which allows or disallows to send notifications
    if (p_write_req->handle == HDLD_SERIAL_GATT_SERIAL_DATA_CLIENT_CONFIGURATION)
    {
        if (p_write_req->val_len != 2)
        {
            return WICED_BT_GATT_CCC_CFG_ERR;
        }
        notifications_enabled = p_write_req->p_val[0] & GATT_CLIENT_CONFIG_NOTIFICATION;

        /* If peer enabled notification (i.e. Enable/Open BSG) */
        if (notifications_enabled)
        {
            /* GATT MTU must have been negotiated before BSG is opened */
            if (serial_gatt_state.peer_mtu == 0)
            {
                WICED_BT_TRACE("Warning: BSG Opened before MTU negotiation!\n");
            }
            else
            {
                /* Peer opened/reopened BSG => send MTU & Initial Credit */
                serial_gatt_service_mtu_handler(conn_id, serial_gatt_state.peer_mtu);
            }

            /* If BSG was already opened */
            if (serial_gatt_state.notifications_enabled)
            {
                WICED_BT_TRACE("Warning: BSG Re-Opened!\n");
                /* Send BSG disconnected event to MCU */
                serial_gatt_service_send_disconnected_evt(serial_gatt_state.conn_id);
            }

            /* Send BSG Connected event to MCU */
            serial_gatt_service_send_connected_evt(serial_gatt_state.peer_bdaddr,
                    serial_gatt_state.conn_id);

            // as client configuration descriptor changed, we might be able to send data
            serial_gatt_service_send_data(WICED_FALSE);
        }
        else
        {
            /* If Tx Data buffer was pending. Cancel it */
            serial_gatt_service_tx_complete(HCI_CONTROL_BSG_STATUS_NOT_CONNECTED);

            /* Send BSG disconnected event to MCU */
            serial_gatt_service_send_disconnected_evt(serial_gatt_state.conn_id);
        }

        serial_gatt_state.notifications_enabled = notifications_enabled;

        return WICED_BT_GATT_SUCCESS;
    }

    // the only characteristic this service allows to write to is Serial Data
    if (p_write_req->handle != HDLC_SERIAL_GATT_SERIAL_DATA_VALUE)
    {
        WICED_BT_TRACE("illegal write handle:%04x\n", p_write_req->handle);
        return WICED_BT_GATT_INVALID_HANDLE;
    }

    /* Parse the Header */
    header_size = serial_gatt_service_header_parse(&credit, &mtu, &p_data, p_write_req->p_val, len);
    if (header_size < 0)
    {
        return WICED_BT_GATT_ERROR;
    }

    /* Restart Idle timer */
    serial_gatt_service_idle_timer_stop();
    if (wiced_start_timer(&serial_gatt_idle_timer, SERIAL_GATT_SERVICE_IDLE_TIMEOUT)
            != WICED_SUCCESS )
    {
        WICED_BT_TRACE("Err: failed to start Idle timer\n");
    }
    /* Change Connection Parameters to Active. */
    serial_gatt_service_change_conn_param(SERIAL_GATT_SERVICE_CONN_ACTIVE);

    /* Skip Header */
    len -= header_size;

    // if we received data try to send it over the transport
    if ((p_data != NULL) && (len > 0))
    {
        /* If no Transport buffer allocated */
        if (serial_gatt_state.rx_buffer_cb.p_transport_buffer == NULL)
        {
            if ((p_trans_buffer = (uint8_t *)wiced_transport_allocate_buffer(
                    serial_gatt_state.p_transport_pool)) == NULL)
            {
                WICED_BT_TRACE("Error no transport buffer\n");
                return WICED_BT_GATT_ERROR;
            }

            /* One more Rx buffer allocated */
            serial_gatt_state.rx_buffer_cb.nb_transport_allocated++;

            // Write ConnectionId in buffer
            p_trans_buffer[0] = conn_id & 0xff;
            p_trans_buffer[1] = (conn_id >> 8) & 0xff;

            // Update Rx buffer Control Block
            serial_gatt_state.rx_buffer_cb.p_transport_buffer = p_trans_buffer;
            serial_gatt_state.rx_buffer_cb.credits = 0;
            serial_gatt_state.rx_buffer_cb.length = 2;      // The two bytes on the ConnId
        }

        p_trans_buffer = serial_gatt_state.rx_buffer_cb.p_transport_buffer +
                   serial_gatt_state.rx_buffer_cb.length;

        // copy received data to transport buffer
        memcpy(p_trans_buffer, p_data, len);

        // Update Rx buffer Control Block
        serial_gatt_state.rx_buffer_cb.credits++;
        serial_gatt_state.rx_buffer_cb.length += len;

        // Restart the Ack timer
        serial_gatt_service_ack_timer_stop();
        if (wiced_start_timer(&serial_gatt_ack_timer, SERIAL_GATT_SERVICE_ACK_TIMEOUT)
                != WICED_SUCCESS )
        {
            WICED_BT_TRACE("Err: failed to start Ack timer\n");
        }

        // Send this buffer to MCU immediately if
        // One more free buffer is available OR
        // No more Rx MTU packet can fit in the current allocated transport buffer
        if ((serial_gatt_state.rx_buffer_cb.nb_transport_allocated <
                SERIAL_GATT_SERVICE_TRANSPORT_BUFF_NB) ||
            (serial_gatt_state.peer_mtu >
               (SERIAL_GATT_SERVICE_TRANSPORT_BUFF_SIZE - serial_gatt_state.rx_buffer_cb.length)))
        {
            uint16_t length;
            uint8_t *p_transport_buffer;
            // Enqueue (Save) the number of credit present in this Transport buffer
            // We will Dequeue (Restore) it when TransportTxCplt Cback will be called
            serial_gatt_service_transport_credit_insert(serial_gatt_state.rx_buffer_cb.credits);

            length = serial_gatt_state.rx_buffer_cb.length;
            p_transport_buffer = serial_gatt_state.rx_buffer_cb.p_transport_buffer;

            // No more Rx transport buffer
            serial_gatt_state.rx_buffer_cb.credits = 0;
            serial_gatt_state.rx_buffer_cb.length = 0;
            serial_gatt_state.rx_buffer_cb.p_transport_buffer = NULL;


            BSG_DEBUG_TRACE("Send Rx Buffer to MCU len:%d", length);
            if (wiced_transport_send_buffer(HCI_CONTROL_BSG_EVENT_RX_DATA,
                    p_transport_buffer, length) != WICED_SUCCESS)
            {
                WICED_BT_TRACE("Err: failed to transport buffer\n");
                return WICED_BT_GATT_ERROR;
            }
        }
    }

    /* If BSG MTU received */
    if (mtu)
    {
        serial_gatt_service_bsg_mtu_handler(mtu);
    }

    if (credit)
    {
        BSG_DEBUG_TRACE("Received %d TxCredits New TxCredit:%d\n", credit,
                serial_gatt_state.tx_credits + credit);
    }

    // process number of credits if received from the peer
    if (credit + serial_gatt_state.tx_credits > SERIAL_GATT_MAX_CREDITS)
    {
        WICED_BT_TRACE("Err: illegal credits cur: len:%d\n", len);
        return WICED_BT_GATT_ERROR;
    }

    // tx_credits indicates how many packets we can send to the peer.
    serial_gatt_state.tx_credits += credit;

#if defined (SERIAL_GATT_TX_CREDITS_LIMIT)
    // Debug: Limit TxCredit
    if (serial_gatt_state.tx_credits > SERIAL_GATT_TX_CREDITS_LIMIT)
    {
        serial_gatt_state.tx_credits = SERIAL_GATT_TX_CREDITS_LIMIT;
        WICED_BT_TRACE("Limit TxCredits to %d\n", SERIAL_GATT_TX_CREDITS_LIMIT);
    }
#endif

    // as we got more credits, we might be able to send data out, or may need to send credits.
    serial_gatt_service_send_data(WICED_FALSE);

    return status;
}

/*
 * Handles Read Requests received from Client device
 */
wiced_bt_gatt_status_t serial_gatt_service_read_handler(uint16_t conn_id, wiced_bt_gatt_read_t *p_read_req)
{
    wiced_bt_gatt_status_t status;

    /* only readable attribute is characteristic client configuration descriptor */
    if (p_read_req->handle == HDLD_SERIAL_GATT_SERIAL_DATA_CLIENT_CONFIGURATION)
    {
        if (*p_read_req->p_val_len < 2)
        {
            status = WICED_BT_GATT_ILLEGAL_PARAMETER;
        }
        else
        {
            *p_read_req->p_val_len = 2;

            p_read_req->p_val[0]   = serial_gatt_state.notifications_enabled ? GATT_CLIENT_CONFIG_NOTIFICATION : GATT_CLIENT_CONFIG_NONE;
            p_read_req->p_val[1]   = 0;

            status = WICED_BT_GATT_SUCCESS;
        }
    }
    else
    {
        status = WICED_BT_GATT_INVALID_HANDLE;
    }
    return status;
}

/*
 * Handle peer request to set MTU
 */
wiced_bt_gatt_status_t serial_gatt_service_mtu_handler(uint16_t conn_id, uint16_t mtu)
{
    serial_gatt_service_mtu_timer_stop();

    serial_gatt_state.peer_mtu = mtu;
    serial_gatt_state.mtu_update = WICED_TRUE;

    // MTU can be 23 - 512. We created a pool of X buffers of 512 bytes.
    // The nnumber of RxCredit is: (512 / mtu) + (X - 1)
    serial_gatt_state.rx_credits_max = SERIAL_GATT_SERVICE_RX_MTU / mtu;
    serial_gatt_state.rx_credits_max += SERIAL_GATT_SERVICE_TRANSPORT_BUFF_NB - 1;
    serial_gatt_state.rx_credits = serial_gatt_state.rx_credits_max;

    WICED_BT_TRACE("MTU handler mtu:%d num transport buffers:%d ccc:%d\n", mtu,
            serial_gatt_state.rx_credits_max, serial_gatt_state.notifications_enabled);

    // transmit initial number of credits
    serial_gatt_service_send_data(WICED_FALSE);

    return WICED_BT_GATT_SUCCESS;
}

/*
 * Handle peer request to set BSG MTU
 */
static void serial_gatt_service_bsg_mtu_handler(uint16_t mtu)
{
    WICED_BT_TRACE("BSG MTU handler mtu:%d\n", mtu);

    if (mtu > serial_gatt_state.peer_mtu)
    {
        WICED_BT_TRACE("Err: BSG Rx MTU (%d) is bigger than GATT MTU (%d)\n",
                mtu, serial_gatt_state.peer_mtu);
    }
}

/*
 * Connection Up processing
 */
void serial_gatt_service_connection_up(wiced_bt_gatt_connection_status_t *p_conn_status)
{
    int     i;

    // Device has connected
    WICED_BT_TRACE("bsg_server.connection_up: BDA:%B conn_id:%d\n", p_conn_status->bd_addr,
            p_conn_status->conn_id);
    serial_gatt_state.conn_id = p_conn_status->conn_id;

    // Save peer's BdAddr
    memcpy(serial_gatt_state.peer_bdaddr, p_conn_status->bd_addr, BD_ADDR_LEN);

    // We need to assume that MTU is 23 bytes and calculate Rx credit when timer expires
    serial_gatt_state.peer_mtu              = 0;
    serial_gatt_state.notifications_enabled = WICED_FALSE;

    if (wiced_start_timer(&serial_gatt_mtu_timer, SERIAL_GATT_SERVICE_MTU_NEGOTIATION_TIMEOUT) != WICED_SUCCESS )
    {
        WICED_BT_TRACE("Err: failed to start mtu timer\n");
    }
}

/*
 * Connection Down processing
 */
void serial_gatt_service_connection_down(wiced_bt_gatt_connection_status_t *p_conn_status)
{
    int     i;

    // Device has disconnected
    WICED_BT_TRACE("bsg_server.connection_down: BDA:%B conn_id:%d Reason:%d\n", p_conn_status->bd_addr,
            p_conn_status->conn_id, p_conn_status->reason);

    serial_gatt_service_tx_complete(HCI_CONTROL_BSG_STATUS_NOT_CONNECTED);

    /* If Link Disconnected while BSG Opened */
    if (serial_gatt_state.notifications_enabled)
    {
        /* Send BSG disconnected event to MCU */
        serial_gatt_service_send_disconnected_evt(serial_gatt_state.conn_id);
    }

    /* Stop any active timer */
    serial_gatt_service_mtu_timer_stop();
    serial_gatt_service_ack_timer_stop();
    serial_gatt_service_idle_timer_stop();

    /* Free any pending Rx */
    if (serial_gatt_state.rx_buffer_cb.p_transport_buffer)
    {
        wiced_transport_free_buffer(serial_gatt_state.rx_buffer_cb.p_transport_buffer);
        serial_gatt_state.rx_buffer_cb.p_transport_buffer = NULL;
        serial_gatt_state.rx_buffer_cb.credits = 0;
        serial_gatt_state.rx_buffer_cb.length = 0;
    }

    /* Clear all the Connection related information */
    serial_gatt_state.notifications_enabled = 0;
    serial_gatt_state.tx_credits= 0;
    serial_gatt_state.rx_credits_max = 0;
    serial_gatt_state.rx_credits = 0;
    serial_gatt_state.tx_len = 0;
    serial_gatt_state.tx_offset = 0;
    serial_gatt_state.peer_mtu = 0;
    serial_gatt_state.mtu_update = WICED_FALSE;
    serial_gatt_state.conn_id = 0;
    memset(serial_gatt_state.peer_bdaddr, 0, BD_ADDR_LEN);
    memset(&serial_gatt_state.rx_buffer_cb, 0, sizeof(serial_gatt_state.rx_buffer_cb));
    serial_gatt_state.conn_state = SERIAL_GATT_SERVICE_CONN_IDLE;
}

/*
 * Handle received command over WICED HCI UART.
 */
uint32_t serial_gatt_service_process_wiced_hci_command(uint16_t opcode, uint8_t *p_tx_buffer,
        uint16_t offset, uint32_t length)
{
    uint32_t buffer_processed = WICED_TRUE;

    switch(opcode)
    {
    case HCI_CONTROL_BSG_COMMAND_DATA:
        // first 2 bytes of the command from the MCU are connection ID. Skip it.
        buffer_processed = serial_gatt_service_process_forward_data(p_tx_buffer,offset + 2,
                length - 2);
        break;

    default:
        WICED_BT_TRACE("cmd_opcode 0x%02x ignored\n", opcode);
        break;
    }
    return buffer_processed;
}

/*
 * Handle forward data packet
 */
static wiced_bool_t serial_gatt_service_process_forward_data(uint8_t *p_buffer, uint16_t offset,
        uint16_t length)
{
    BSG_DEBUG_TRACE("BSG Data Tx len:%d\n", length);

    if (!serial_gatt_state.notifications_enabled)
    {
        WICED_BT_TRACE("Err: fwd data when BSG closed\n");
        serial_gatt_service_send_tx_complete_evt(0, HCI_CONTROL_BSG_STATUS_NOT_CONNECTED);
        return WICED_TRUE;
    }

    if (serial_gatt_state.p_tx_buffer != NULL)
    {
        WICED_BT_TRACE("Err: fwd data with buffer present\n");
        serial_gatt_service_send_tx_complete_evt(serial_gatt_state.conn_id,
                HCI_CONTROL_BSG_STATUS_OVERRUN);
        return WICED_TRUE;
    }

    serial_gatt_state.p_tx_buffer = p_buffer;
    serial_gatt_state.tx_offset   = offset;
    serial_gatt_state.tx_len      = length;

    serial_gatt_service_send_data(WICED_FALSE);
    return WICED_FALSE;
}

/*
 * if we have credits and there is a tx buffer, send it now.  Return TRUE if buffer was sent out.
 * Parameter return_credits is set to TRUE if it is time to send credits to peer
 */
void serial_gatt_service_send_data(wiced_bool_t return_credits)
{
    wiced_bt_gatt_status_t status;
    uint16_t bytes_to_send;
    uint8_t flags;
    const int MTU_OVERHEAD = 3;

    if (!serial_gatt_state.notifications_enabled)
    {
        return;
    }

    /* Restart Idle timer */
    serial_gatt_service_idle_timer_stop();
    if (wiced_start_timer(&serial_gatt_idle_timer, SERIAL_GATT_SERVICE_IDLE_TIMEOUT)
            != WICED_SUCCESS )
    {
        WICED_BT_TRACE("Err: failed to start Idle timer\n");
    }
    /* Change Connection Parameters to Active. */
    serial_gatt_service_change_conn_param(SERIAL_GATT_SERVICE_CONN_ACTIVE);

    // if tx buffer is empty OR if No Tx Credit, we may still need to send credits
    if ((serial_gatt_state.p_tx_buffer == NULL) || (serial_gatt_state.tx_credits == 0))
    {
        if ((serial_gatt_state.rx_credits != 0) &&
            (return_credits || (serial_gatt_state.rx_credits >= (serial_gatt_state.rx_credits_max / 2))))
        {
            uint8_t buffer[4];

            if (serial_gatt_state.mtu_update)
            {
                BSG_DEBUG_TRACE("BSG Send Credit:%d and MTU:%d\n",
                        serial_gatt_state.rx_credits, serial_gatt_state.peer_mtu);

                flags = SERIAL_GATT_FLAGS_CREDIT_FIELD_PRESENT |
                        SERIAL_GATT_FLAGS_MTU_FIELD_PRESENT;
            }
            else
            {
                BSG_DEBUG_TRACE("BSG Send Credit:%d\n", serial_gatt_state.rx_credits);
                flags = SERIAL_GATT_FLAGS_CREDIT_FIELD_PRESENT;
            }

            /* Write packet header */
            bytes_to_send = serial_gatt_service_header_write(buffer, flags,
                    serial_gatt_state.rx_credits, serial_gatt_state.peer_mtu);

            status = wiced_bt_gatt_send_notification(serial_gatt_state.conn_id,
                    HDLC_SERIAL_GATT_SERIAL_DATA_VALUE, bytes_to_send, buffer);
            if (status != WICED_BT_GATT_SUCCESS)
            {
                WICED_BT_TRACE("err:wiced_bt_gatt_send_notification (1) failed %d", status);
                return;
            }
            serial_gatt_state.rx_credits = 0;
            serial_gatt_state.mtu_update = WICED_FALSE;
        }
        return;
    }

    while ((serial_gatt_state.tx_credits > 0) && (serial_gatt_state.p_tx_buffer != NULL))
    {
        // send up to peer MTU number of bytes
        uint8_t *p_tmp;
        uint16_t header_size;

        if (serial_gatt_state.rx_credits != 0)
        {
            if (serial_gatt_state.mtu_update)
            {
                /* need to add 4 bytes header (flags, credits and MTU) */
                bytes_to_send = serial_gatt_state.tx_len < serial_gatt_state.peer_mtu - (4 + MTU_OVERHEAD) ?
                     serial_gatt_state.tx_len : serial_gatt_state.peer_mtu - (4 + MTU_OVERHEAD);

                BSG_DEBUG_TRACE("BSG Send Credit:%d MTU:%d Data len:%d\n",
                        serial_gatt_state.rx_credits, serial_gatt_state.peer_mtu, bytes_to_send);

                flags = SERIAL_GATT_FLAGS_CREDIT_FIELD_PRESENT |
                        SERIAL_GATT_FLAGS_MTU_FIELD_PRESENT    |
                        SERIAL_GATT_FLAGS_DATA_FIELD_PRESENT;

                p_tmp = &serial_gatt_state.p_tx_buffer[serial_gatt_state.tx_offset - 4];
            }
            else
            {
                /* need to add 2 bytes header (flags, credits) */
                bytes_to_send = serial_gatt_state.tx_len < serial_gatt_state.peer_mtu - (2 + MTU_OVERHEAD) ?
                     serial_gatt_state.tx_len : serial_gatt_state.peer_mtu - (2 + MTU_OVERHEAD);

                BSG_DEBUG_TRACE("BSG Send Credit:%d and Data len:%d\n",
                        serial_gatt_state.rx_credits, bytes_to_send);

                flags = SERIAL_GATT_FLAGS_CREDIT_FIELD_PRESENT |
                        SERIAL_GATT_FLAGS_DATA_FIELD_PRESENT;

                p_tmp = &serial_gatt_state.p_tx_buffer[serial_gatt_state.tx_offset - 2];
            }

            /* Write packet header */
            header_size = serial_gatt_service_header_write(p_tmp, flags,
                    serial_gatt_state.rx_credits, serial_gatt_state.peer_mtu);

            /* Send the notification */
            status = wiced_bt_gatt_send_notification(serial_gatt_state.conn_id,
                    HDLC_SERIAL_GATT_SERIAL_DATA_VALUE, bytes_to_send + header_size, p_tmp);
            if (status != WICED_BT_GATT_SUCCESS)
            {
                WICED_BT_TRACE("err:wiced_bt_gatt_send_notification (2) failed %d", status);
                return;
            }
        }
        else
        {
            if (serial_gatt_state.mtu_update)
            {
                /* need to add 3 bytes header (flags and MTU) */
                bytes_to_send = serial_gatt_state.tx_len < serial_gatt_state.peer_mtu - (3 + MTU_OVERHEAD) ?
                     serial_gatt_state.tx_len : serial_gatt_state.peer_mtu - (3 + MTU_OVERHEAD);

                BSG_DEBUG_TRACE("BSG Send MTU:%d Data len:%d\n",
                        serial_gatt_state.peer_mtu, bytes_to_send);

                flags = SERIAL_GATT_FLAGS_MTU_FIELD_PRESENT    |
                        SERIAL_GATT_FLAGS_DATA_FIELD_PRESENT;

                p_tmp = &serial_gatt_state.p_tx_buffer[serial_gatt_state.tx_offset - 3];
            }
            else
            {
                /* need to add 1 byte header (flags) */
                bytes_to_send = serial_gatt_state.tx_len < serial_gatt_state.peer_mtu - (1 + MTU_OVERHEAD) ?
                     serial_gatt_state.tx_len : serial_gatt_state.peer_mtu - (1 + MTU_OVERHEAD);

                BSG_DEBUG_TRACE("BSG Send Data len:%d\n", bytes_to_send);

                flags = SERIAL_GATT_FLAGS_DATA_FIELD_PRESENT;

                p_tmp = &serial_gatt_state.p_tx_buffer[serial_gatt_state.tx_offset - 1];
            }

            /* Write packet header */
            header_size = serial_gatt_service_header_write(p_tmp, flags,
                    serial_gatt_state.rx_credits, serial_gatt_state.peer_mtu);

            /* Send the notification */
            status = wiced_bt_gatt_send_notification(serial_gatt_state.conn_id,
                    HDLC_SERIAL_GATT_SERIAL_DATA_VALUE, bytes_to_send + header_size, p_tmp);
            if (status != WICED_BT_GATT_SUCCESS)
            {
                WICED_BT_TRACE("err:wiced_bt_gatt_send_notification (3) failed %d", status);
                return;
            }
        }

        /* One notification sent. Update Credits (Rx/Tx), RemainingLen, Offset and MTU update */
        serial_gatt_state.tx_credits--;
        BSG_DEBUG_TRACE("TxCredit:%d", serial_gatt_state.tx_credits);
        serial_gatt_state.tx_len    -= bytes_to_send;
        serial_gatt_state.tx_offset += bytes_to_send;
        serial_gatt_state.rx_credits = 0;
        serial_gatt_state.mtu_update = WICED_FALSE;

        // if we are done with this buffer, send notification to the MCU and release the buffer
        if (serial_gatt_state.tx_len == 0)
        {
            serial_gatt_service_tx_complete(HCI_CONTROL_BSG_STATUS_SUCCESS);
        }
    }
}

/*
 * Processing of the transport buffer is competed.  Notify MCU and release the buffer.
 */
static void serial_gatt_service_tx_complete(uint8_t result)
{
    uint8_t tx_complete[3];

    if (serial_gatt_state.p_tx_buffer != NULL)
    {
        wiced_transport_free_buffer(serial_gatt_state.p_tx_buffer);
        serial_gatt_state.p_tx_buffer = NULL;

        /* Send BSG Tx Complete Event to MCU */
        serial_gatt_service_send_tx_complete_evt(serial_gatt_state.conn_id, result);
    }
}

/*
 * serial_gatt_service_send_connected_evt
 */
static void serial_gatt_service_send_connected_evt(uint8_t *bd_addr, uint16_t conn_id)
{
    uint8_t evt_param[BD_ADDR_LEN + sizeof(uint16_t)];
    uint8_t *p = evt_param;

    WICED_BT_TRACE("BSG Connected Evt BdAddr:%B conn_id:%d\n", bd_addr, conn_id);

    BDADDR_TO_STREAM(p, bd_addr);
    UINT16_TO_STREAM(p, conn_id);

    if (wiced_transport_send_data(HCI_CONTROL_BSG_EVENT_CONNECTED, evt_param,
            sizeof(evt_param)) != WICED_SUCCESS)
    {
        WICED_BT_TRACE("Err: failed to send connected event\n");
    }
}

/*
 * serial_gatt_service_send_disconnected_evt
 */
static void serial_gatt_service_send_disconnected_evt(uint16_t conn_id)
{
    uint8_t evt_param[sizeof(uint16_t)];
    uint8_t *p = evt_param;

    WICED_BT_TRACE("BSG Disconnected Evt conn_id:%d\n", conn_id);

    UINT16_TO_STREAM(p, conn_id);

    if (wiced_transport_send_data(HCI_CONTROL_BSG_EVENT_DISCONNECTED, evt_param,
            sizeof(evt_param)) != WICED_SUCCESS)
    {
        WICED_BT_TRACE("Err: failed to send disconnected event\n");
    }
}

/*
 * serial_gatt_service_send_tx_complete_evt
 */
static void serial_gatt_service_send_tx_complete_evt(uint16_t conn_id, uint8_t result)
{
    uint8_t tx_complete[3];

    BSG_DEBUG_TRACE("BSG Tx Cfm Evt\n");

    tx_complete[0] = conn_id & 0xff;
    tx_complete[1] = (conn_id >> 8) & 0xff;
    tx_complete[2] = result;

    if (wiced_transport_send_data(HCI_CONTROL_BSG_EVENT_TX_COMPLETE, tx_complete, sizeof(tx_complete)) != WICED_SUCCESS)
    {
        WICED_BT_TRACE("Err: failed to send tx_complete event\n");
    }
}

/*
 * serial_gatt_service_transport_tx_cplt_cback
 * Called when a buffer has been sent(freed) to the MCU
 */
void serial_gatt_service_transport_tx_cplt_cback(wiced_transport_buffer_pool_t* p_pool)
{
    /* If the sent(freed) buffer belongs to the BSG buffer pool */
    if (serial_gatt_state.p_transport_pool == p_pool)
    {
        BSG_DEBUG_TRACE("BSG Transport tx cfm\n");

        /* One Rx buffer freed */
        serial_gatt_state.rx_buffer_cb.nb_transport_allocated--;

        /* Update number of RxCredit */
        serial_gatt_state.rx_credits += serial_gatt_service_transport_credit_extract();

        /* Send number of RxCredit to peer */
        serial_gatt_service_send_data(WICED_FALSE);

        /* One Rx Transport Buffer has been freed. Check if one is ready to be sent to MCU */
        if (serial_gatt_state.rx_buffer_cb.p_transport_buffer)
        {
            uint16_t length;
            uint8_t *p_transport_buffer;

            // Enqueue (Save) the number of credit present in this Transport buffer
            // We will Dequeue (Restore) it when TransportTxCplt Cback will be called
            serial_gatt_service_transport_credit_insert(serial_gatt_state.rx_buffer_cb.credits);

            length = serial_gatt_state.rx_buffer_cb.length;
            p_transport_buffer = serial_gatt_state.rx_buffer_cb.p_transport_buffer;

            // No more Rx transport buffer
            serial_gatt_state.rx_buffer_cb.credits = 0;
            serial_gatt_state.rx_buffer_cb.length = 0;
            serial_gatt_state.rx_buffer_cb.p_transport_buffer = NULL;


            BSG_DEBUG_TRACE("Send Rx Buffer to MCU len:%d", length);
            if (wiced_transport_send_buffer(HCI_CONTROL_BSG_EVENT_RX_DATA,
                    p_transport_buffer, length) != WICED_SUCCESS)
            {
                WICED_BT_TRACE("Err: failed to transport buffer\n");
                return;
            }
        }
    }
}

/*
 * serial_gatt_service_transport_credit_insert
 * Save (Enqueue) the number of Credit associated with one Rx transport buffer
 */
static void serial_gatt_service_transport_credit_insert(uint8_t credit)
{
    serial_gatt_credit_queue_t *p_credit_queue;

    BSG_DEBUG_TRACE("BSG Insert credit:%d\n", credit);

    p_credit_queue = &serial_gatt_state.rx_buffer_cb.credit_queue;

    p_credit_queue->credit[p_credit_queue->in] = credit;
    p_credit_queue->in++;
    if (p_credit_queue->in >= (sizeof(p_credit_queue->credit) / sizeof(p_credit_queue->credit[0])))
    {
        p_credit_queue->in = 0;
    }
}

/*
 * serial_gatt_service_transport_credit_extract
 * Restore (Dequeue) the number of Credit associated with one Rx transport buffer
 */
static uint8_t serial_gatt_service_transport_credit_extract(void)
{
    serial_gatt_credit_queue_t *p_credit_queue;
    uint8_t credit;

    p_credit_queue = &serial_gatt_state.rx_buffer_cb.credit_queue;

    credit = p_credit_queue->credit[p_credit_queue->out];
    p_credit_queue->out++;
    if (p_credit_queue->out >= (sizeof(p_credit_queue->credit) / sizeof(p_credit_queue->credit[0])))
    {
        p_credit_queue->out = 0;
    }

    BSG_DEBUG_TRACE("BSG Extract credit:%d\n", credit);

    return credit;
}

/*
 * serial_gatt_service_header_write
 * Write packet header (flags, credit, mtu)
 */
static uint16_t serial_gatt_service_header_write(uint8_t *p_buffer, uint8_t flags,
                    uint8_t credits, uint16_t mtu)
{
    uint8_t *p = p_buffer;

    UINT8_TO_STREAM(p, flags);

    /* If Credit flag set */
    if (flags & SERIAL_GATT_FLAGS_CREDIT_FIELD_PRESENT)
    {
        UINT8_TO_STREAM(p, credits);        /* Insert Credits field */
    }
    /* If MTU flag set */
    if (flags & SERIAL_GATT_FLAGS_MTU_FIELD_PRESENT)
    {
        UINT16_TO_STREAM(p, mtu);           /* Insert MTU field */
    }

    /* Return number of bytes written */
    return (uint16_t)(p - p_buffer);
}

/*
 * serial_gatt_service_header_parse
 */
static int serial_gatt_service_header_parse(uint8_t *p_credits, uint16_t *p_mtu,
        uint8_t **pp_data, uint8_t *p_buffer, uint16_t buffer_len)
{
    uint8_t *p = p_buffer;
    uint8_t flags;

    /* Received buffer must contain at least two bytes  */
    if (buffer_len < 2)
    {
        WICED_BT_TRACE("Err: BSG Illegal len:%d\n", buffer_len);
        return -1;
    }

    STREAM_TO_UINT8(flags, p);
    buffer_len--;

    /* If No flag set, this is an invalid packet */
    if (flags == 0)
    {
        WICED_BT_TRACE("Err: BSG no Flag set\n");
        return -1;
    }

    /* If Credit flag set */
    if (flags & SERIAL_GATT_FLAGS_CREDIT_FIELD_PRESENT)
    {
        STREAM_TO_UINT8(*p_credits, p);        /* Extract Credits field */
        buffer_len--;
    }
    else
    {
        *p_credits = 0;
    }

    /* If MTU flag set */
    if (flags & SERIAL_GATT_FLAGS_MTU_FIELD_PRESENT)
    {
        /* MTU is two bytes  */
        if (buffer_len < 2)
        {
            WICED_BT_TRACE("Err: BSG Illegal MTU len\n");
            return -1;
        }
        STREAM_TO_UINT16(*p_mtu, p);           /* Extract MTU field */
        buffer_len -= 2;
    }
    else
    {
        *p_mtu = 0;
    }

    /* If Data flag set */
    if (flags & SERIAL_GATT_FLAGS_DATA_FIELD_PRESENT)
    {
        *pp_data = p;
    }
    else
    {
        *pp_data = NULL;
    }

    /* Return number header size */
    return (p - p_buffer);
}

/*
 * serial_gatt_service_change_conn_param
 */
static void serial_gatt_service_change_conn_param(serial_gatt_service_conn_t conn_state)
{
    wiced_bool_t res;

    /* If same connection state, do nothing */
    if (serial_gatt_state.conn_state == conn_state)
    {
        return;
    }

    /* Save new connection State */
    serial_gatt_state.conn_state = conn_state;

    /* If Serial Connection is active (data sent/received) */
    if (conn_state == SERIAL_GATT_SERVICE_CONN_ACTIVE)
    {
        BSG_DEBUG_TRACE("BSG Active. Reduce Connection Interval\n");
        res = wiced_bt_l2cap_update_ble_conn_params(serial_gatt_state.peer_bdaddr,
                SERIAL_GATT_SERVICE_ACTIVE_INT_MIN,
                SERIAL_GATT_SERVICE_ACTIVE_INT_MAX,
                SERIAL_GATT_SERVICE_ACTIVE_LATENCY,
                SERIAL_GATT_SERVICE_ACTIVE_CONN_TIMEOUT);
    }
    else
    {
        BSG_DEBUG_TRACE("BSG Idle. Increase Connection Interval\n");
        res = wiced_bt_l2cap_update_ble_conn_params(serial_gatt_state.peer_bdaddr,
                SERIAL_GATT_SERVICE_IDLE_INT_MIN,
                SERIAL_GATT_SERVICE_IDLE_INT_MAX,
                SERIAL_GATT_SERVICE_IDLE_LATENCY,
                SERIAL_GATT_SERVICE_IDLE_CONN_TIMEOUT);
    }
    if (res != WICED_TRUE)
        WICED_BT_TRACE("Err: L2CA_UpdateBleConnParams failed");
}

